package chapter8;

public class Student {
    /** 정리해 봅시다
     * 1. 생성자는 반드시 만들어야 하나요?
     *      생성자를 하나도 선언하지 않고 컴파일할 시 매개변수가 없는 기본 생성자가 만들어지므로 반드시 만들지 않아도 된다.
     *
     * 2. 만약 매개 변수가 있는 생성자를 만들고, 매개 변수가 없는 기본 생성자를 호출하면 어떻게 될까요?
     *      기본 생성자가 아닌 다른 생성자를 만든 후에는, 기본 생성자가 자동으로 생성되지 않으므로 컴파일 에러가 발생한다.
     *
     * 3. 생성자의 개수는 제한이 있나요?
     *      제한 없음
     *
     * 4. 인스턴스의 변수와 매개 변수나 메소드 내에서 생성한 변수와 구분하기 위해서 사용하는 키워드는 무엇인가요?
     *      this
     *
     * 5. 메소드 선언 시 리턴 타입으로 지정한 데이터를 넘겨줄 때 필요한 키워드는 무엇인가요?
     *      return
     *
     * 6. 메소드 선언 시 아무 데이터도 리턴 타입으로 넘겨주지 않겠다는 것을 지정하는 키워드는 무엇인가요?
     *      void
     *
     * 7. 메소드 선언에 static이 있는 것과 없는 것의 차이는 무엇인가요?
     *      객체 생성 없이도 메서드 호출이 가능.
     *
     * 8. 필자가 엄청나게 중요하다고 한 것 중 메소드의 이름은 같으나 매개 변수를 다르게 하는 것의 명칭은 무엇인가요?
     *      overloading
     *
     * 9. 기본 자료형을 매개 변수로 넘겨 줄 때 Pass by Value인가요? 아니면 Pass by reference인가요?
     *      Pass by Value
     *
     * 10. 참조 자료형을 매개 변수로 넘겨 줄 때 Pass by value인가요? Pass by reference인가요?
     *      (교재) Pass by reference
     *      자바는 항상 pass by value. 다만 참조형일 경우 “참조값”이 복사되므로 내부 상태 변경은 호출자에게 보인다.
     *
     * 11. 매개 변수의 수가 가변적일 때 메소드 선언 시 타입과 변수 이름 사이에 어떤 것을 적어줘야 하나요?
     *      ... (가변인자 키워드)
     */
    String name;
    String address;
    String phone;
    String email;

    public Student(String name) {
        /** 생성자 체이닝
         *  - name만 받는 생성자가 자기 클래스 안의 다른 생성자(모든 필드 버전)를 호출.
         *  - 중복 없이 한 곳에서만 필드 초기화 코드를 관리할 수 있음.
         *
         * 생성자 체이닝의 일반적인 패턴
         *  1) “모든 필드를 다 받는 생성자”를 중앙 허브로 만들어 둔다.
         *  2) 그다음 “일부 필드만 받는 생성자”들은 결국 이 허브 생성자를 호출해서 값을 채우고, 나머지는 null이나 기본값으로 채워준다.
         *
         * 체이닝(this())의 의미
         *      this(...) → 같은 클래스 안의 다른 생성자를 호출.
         *      반드시 생성자의 첫 줄에 와야 함. (안 그러면 컴파일 에러)
         *
         * 사용하는 이유?
         *  1) 중복 제거: 모든 생성자가 공통 필드 초기화를 반복하지 않고, 한 곳(메인 생성자)에서만 관리.
         *  2) 일관성: 필드 초기화 규칙을 바꾸고 싶으면 메인 생성자만 고치면 됨.
         */
        this(name, null, null, null);
    }
    public Student(String name, String address, String phone, String email) {
        this.name = name;
        this.address = address;
        this.phone = phone;
        this.email = email;
    }

    /** @Override
     *  컴파일러에게 “이 메서드는 부모 클래스(또는 인터페이스)의 메서드를 재정의한 것이다”라고 알려주는 어노테이션
     *
     *  사용하는 이유?
     *  1) 오타·시그니처 오류 방지
     *      Object.toString()을 재정의하기 위함인데 만약 "tostring"으로 적고 @Override를 붙였다면 컴파일 에러 발생 → 실수를 바로 잡을 수 있음.
     *  2) 가독성
     *      코드 읽는 사람에게 “이건 새로운 메서드가 아니라 상속받은 걸 재정의한 거야”라고 명확히 보여줌.
     *  3) 유지보수 안정성
     *      부모 클래스나 인터페이스의 메서드 시그니처가 변경되면, @Override가 붙은 부분에서 컴파일 에러가 터짐 → 안전하게 수정할 수 있음.
     *
     * 실무 팁: equals, hashCode, toString 같은 Object 기본 메서드 재정의에는 거의 항상 붙인다.
     */
    @Override
    public String toString() {
        return name + " " + address + " " + phone + " " + email;
    }
}
